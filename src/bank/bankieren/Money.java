/* Generated by Together */

package bank.bankieren;

import javafx.beans.InvalidationListener;
import javafx.beans.Observable;

import java.io.*;
import java.text.*;
import java.util.List;

public class Money implements Serializable, Comparable<Money>, Observable {

	private static final long serialVersionUID = 1L;

	public static final String EURO = "\u20AC";


/*	private Money() {
		currency="undefined";
	}
*/
	/**
	 * er is een geldbedrag van munteenheid currency en waarde cents gecreeerd
	 * 
	 * @param amount
	 * @param currency
	 * @throws RuntimeException
	 *             als currency een lege string is
	 */
	public Money(long cents, String currency) {
		if (currency.equals(""))
			throw new RuntimeException("currency may not be the empty string");

		this.cents=cents;
		this.currency = currency;
	}

	/**
	 * 
	 * @return de munteenheid gevolgd door een spatie en de waarde in twee
	 *         decimalen nauwkeurig
	 */
	public String toString() {

		return currency + " " + getValue();
	}

	/**
	 * 
	 * @return <b>true</b> als het Money-object groter dan 0 is, anders
	 *         <b>false</b>
	 */
	public boolean isPositive() {
		return cents > 0;
	}

	public String getCurrency() {
		return currency;
	}

	/**
	 * 
	 * @return de waarde in twee decimalen nauwkeurig
	 */
	public String getValue() {
		DecimalFormat df = new DecimalFormat("0.00");
		return df.format(((double) cents) / 100);

	}

	public long getCents() {
		return cents;
	}

	/**
	 * voorwaarde: currency van m1 en m2 moeten gelijk zijn
	 * @returns het verschil tussen m1 en m2
	 */
	public static Money difference(Money m1, Money m2) {
		if (!m1.currency.equals(m2.currency))
			throw new RuntimeException("munteenheden in aanroep 'difference' ongelijk, te weten: " +
					m1.currency + " en " + m2.currency
					);
		return new Money(m1.cents-m2.cents, m1.currency);
	}

	/**
	 * voorwaarde: currency van m1 en m2 moeten gelijk zijn
	 * @returns de som van m1 en m2
	 */
	public static Money sum(Money m1, Money m2) {
		if (!m1.currency.equals(m2.currency))
			throw new RuntimeException("munteenheden in aanroep 'sum' ongelijk, te weten: " +
					m1.currency + " en " + m2.currency
					);
		return new Money(m1.cents+m2.cents, m1.currency);
	}

	public boolean equals(Object o) {
		if (!(o instanceof Money))
			return false;
		Money m = (Money) o;
		return this.currency.equals(m.currency) && this.cents == m.cents;
	}

	private String currency;

	private long cents;

	public int compareTo(Money o) {
		Money m = (Money) o;
		if (!this.currency.equals(m.currency)) 
			throw new RuntimeException("comparing amounts with different currency is not implemented");
		if (this.cents==m.cents) return 0;
		if (this.cents<m.cents) return -1;
		else return +1;
		
	}

	/**
	 * Adds an {@link javafx.beans.InvalidationListener} which will be notified whenever the
	 * {@code Observable} becomes invalid. If the same
	 * listener is added more than once, then it will be notified more than
	 * once. That is, no check is made to ensure uniqueness.
	 * <p>
	 * Note that the same actual {@code InvalidationListener} instance may be
	 * safely registered for different {@code Observables}.
	 * <p>
	 * The {@code Observable} stores a strong reference to the listener
	 * which will prevent the listener from being garbage collected and may
	 * result in a memory leak. It is recommended to either unregister a
	 * listener by calling {@link #removeListener(javafx.beans.InvalidationListener)
	 * removeListener} after use or to use an instance of
	 * {@link WeakInvalidationListener} avoid this situation.
	 *
	 * @param listener The listener to register
	 * @throws NullPointerException if the listener is null
	 * @see #removeListener(javafx.beans.InvalidationListener)
	 */
	@Override
	public void addListener(InvalidationListener listener) {

	}

	/**
	 * Removes the given listener from the list of listeners, that are notified
	 * whenever the value of the {@code Observable} becomes invalid.
	 * <p>
	 * If the given listener has not been previously registered (i.e. it was
	 * never added) then this method call is a no-op. If it had been previously
	 * added then it will be removed. If it had been added more than once, then
	 * only the first occurrence will be removed.
	 *
	 * @param listener The listener to remove
	 * @throws NullPointerException if the listener is null
	 * @see #addListener(javafx.beans.InvalidationListener)
	 */
	@Override
	public void removeListener(InvalidationListener listener) {

	}
}
